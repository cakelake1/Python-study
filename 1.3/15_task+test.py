""" Танковый раш
Разведчики выяснили, что неведомый клан готовит внезапный массивный прорыв премиум-танков. У нашей арты будет возможность произвести только один залп. 
Ваша задача: выявить местонахождение группировки танков на карте.
На входе два массива (карта и группировка танков), каждый описывается одинаково: количество строк, количество столбцов и набор строк, разделённых пробелом. Каждый символ строки описывает один элемент карты.
Например, дана карта:
1234
2345
0987
Этот массив размером 3*4 будет представлен на вводе так:
3 4 1234 2345 0987
Второй массив представляется аналогично первому.
Задача: проверить, входит ли второй массив в первый (в двумерном виде).
Например, второй массив может быть таким:
34
98
или
2 2 34 98
Он входит в состав первого массива.
Функция
bool TankRush(int H1, int W1, string S1, int H2, intW2, string S2) 
первыми тремя параметрами получает исходную карту, а следующими тремя -- карту, которая ищется в исходной.
TankRush возвращает true, если вторая карта содержится в первой.
Рефлексирую: 
    На первый взгяд хочу сразу сделать проверку на размер второго массива, если он меньше первого, то False.
и хочется сделать простую проверку по строке. Хотя в задании написано конкретная проверка в двумерном виде и скорее всего лучге сделать через двойной цикл.
Есть подсказка в виде пробела между строк, мы можем строки засплитовать и записать их в матрицу и уже в матрицу сделать проверку пстрочно и по столбцам(а надо ли делать по столбцам??)
 """

def TankRush(H1, W1, S1, H2, W2, S2):
    map1 = S1.split()
    map2 = S2.split()
    if H2 > H1 or W2 > W1:
        return False
    if H2 == 0 or W2 == 0:
        return True
    for i in range(H1 - H2 + 1):
        for j in range(W1 - W2 + 1):
            match = True
            for k in range(H2):
                if map1[i+k][j:j + W2] != map2[k]:
                        match = False
                        break
            if match: 
                return True
    return False
""" print(TankRush(3,4,'1234 2345 0987', 2, 2, '34 98')) # True
print(TankRush(3, 4, "1234 5678 9012", 2, 2, "67 01"))  # True
print(TankRush(3, 4, "1234 5678 9012", 2, 2, "67 90"))  # False
print(TankRush(1, 1, "1", 1, 1, "1"))  # True
print(TankRush(2, 2, "12 34", 3, 2, "12 34 56"))  # False (искомая карта больше)
print(TankRush(3, 4, "1234 5678 9012", 2, 2, "12 56"))  # True (искомая карта начинается с (0,0)) """
print(TankRush(4, 4, "1234 5678 9001 3456", 2, 2, "78 01")) # True (искомая карта с позиции (1,2))
""" print(TankRush(3, 4, "ABCD EFGH IJKL", 1, 3, "JKL"))  # True (последняя строка, позиция (2,1))
print(TankRush(3, 3, "ABC DEF GHI", 2, 2, "AB DE"))  # False (первая строка совпадает, но вторая - нет)
print(TankRush(2, 2, "12 34", 3, 3, "123 456 789"))  # False (искомая карта превышает размер основной)
print(TankRush(3, 3, "ABC DEF GHI", 0, 0, ""))  # True (пустая карта всегда содержится)
print(TankRush(2, 2, "AB CD", 1, 1, "C"))  # True (символ в позиции (1,1))
print(TankRush(2, 2, "AB CD", 1, 1, "E"))  # False (символ 'E' отсутствует)
print(TankRush(3, 4, "AAAA AAAA AAAA", 2, 2, "AA AA"))  # True (найдет первое вхождение в (0,0))
print(TankRush(2, 3, "ABC DEF", 2, 2, "AB DE"))  # True (совпадет подматрица [[A,B],[D,E]])
print(TankRush(2, 3, "A1! B2@ C3#", 1, 2, "2@"))  # True (позиция (1,1))
print(TankRush(5, 5, "12345 67890 ABCDE FGHIJ KLMNO", 2, 2, "IJ NO"))  # True (позиция (3,3)) """