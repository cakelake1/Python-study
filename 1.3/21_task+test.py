""" Гарри Поттер идёт в первый класс Хогвартса
Казалось бы, чего тут сложного -- выучил несколько колдовских слов, произнёс, и... никакого эффекта. Именно поэтому в специальных учебных заведениях наподобие Хогвартса вербальную магию изучают годами. Дело в том, что в волшебных учебниках написаны слова заклинания, которые сами по себе не работают. Их надо уметь преобразовывать в действующую магию с помощью специальных алгоритмов. Давайте познакомимся с одним из них.
У нас имеется не-магическое слово -- стандартная последовательность русских и английских букв (строковый тип). Такие слова в любом языке программирования можно сравнивать, используя обычный лексикографический порядок, когда "а" меньше чем "я", "a" меньше чем "z" и т. д.
Задача: преобразовать такое слово в магическое с помощью любого числа перестановок двух любых букв в слове, либо убедиться, что получить магическое слово невозможно.
Итоговое слово должно отвечать двум требованиям:
1) оно лексикографически больше, чем исходное слово;
2) оно наименьшее из всех лексикографически больших слов, которые можно получить перестановкой пары букв.
Тестовые примеры:
"ая" преобразовываем в "яа"
"fff" - невозможно преобразовать
"нклм" в "нкмл"
"вибк" в "викб"
"вкиб" в "ибвк"
Функция
string BiggerGreater(string input)
получает на вход исходную строку длиной 2 или более русских или английских строковых (маленьких) букв, и возвращает итоговое магическое слово. Если получить его невозможно, возвращается пустая строка.
Например, BiggerGreater("вибк") = "викб"; BiggerGreater("fff") = "".
Рефлексируем:
    На первый взгляд хочется сделать словарь с числовыми значениями. Сейчас попробую немного поизучать тему лексографическрого соотвествия.
Поизучал - Значение лексографиского слова можно соотнести с порядками в числах, если возьмем число 1234 и поменяем на 2134, то мы изменим число, но лескографически оно будет большим.
Если поменяем на 1243 получаем минимальное лексографическое слово, поэтому в алгоритме нужно идти справа налево и мы закроем сразу два основных условия задачи:
1) оно лексикографически больше, чем исходное слово;
2) оно наименьшее из всех лексикографически больших слов, которые можно получить перестановкой пары букв.
 поэтому алгоритм будет такой:
    1. Переводим строку в список
    2. Находим самый большой индекс i с конца, где S[i] > S[i] + 1, поэтому начинаем сравнивать со второго символа, где длина будет(n-2), при этом делаем проверку условия на пустую строку и движемся в обратном направлении
    3. Находим самый большой индекс j, где j > i, S[j] > S[i], где также движемся в обратном направлении и начинаем проверить с первого элемента с конца(n-1)
    4. Меняем местами S[i] и S[j]
вот мы поменяли первый пример - он сработал, поменяли второй пример - получили пустую строку - сработал.третий - сработал, четвертый не сработал, а чтобы четвертный пример сработал - нужно отсортировать
    5. В данном случае достаточно отсортировать, просто "перевернув звост" - Можно сделать через срез[::-1] или через reversed
    6. вывод строки """

def BiggerGreater(input_s):
    s = list(input_s)
    n = len(s)
    i = n - 2
    while i >= 0 and s[i] >= s[i+1]:
        i -= 1
    if i < 0:
        return ""
    j = n - 1
    while j > i and s[j] <= s[i]:
        j -= 1
    s[i], s[j] = s[j], s[i]
    s[i + 1:] = reversed(s[i + 1:])
    result = ''.join(s)
    return result 

print(BiggerGreater("ая"))    # "яа"
print(BiggerGreater("fff"))   # ""
print(BiggerGreater("нклм"))  # "нкмл"
print(BiggerGreater("вибк"))  # "викб"
print(BiggerGreater("вкиб"))  # "ибвк"
print(BiggerGreater("abc"))  # "acb"
print(BiggerGreater("abcdefg"))  # "abcdegf"
print(BiggerGreater("dcba"))  # ""
print(BiggerGreater("aabb"))  # "abab"
print(BiggerGreater("ba"))  # ""
print(BiggerGreater("appleяблоко"))    # "appleяблокo"
print(BiggerGreater("тестtest"))    # "тестtets"
print(BiggerGreater("ab"))  # nono
print(BiggerGreater("мирworld"))  # мирwrdlo
print(BiggerGreater("abcdefghijklmnopqrstuvwxyz"))  # abcdefghijklmnopqrstuvwxzy
print(BiggerGreater("абвгдеёжзийклмнопрстуфхцчшщъыьэюя"))  # ytn
"ВАЖНО!! этот пример не срабатывает, так как у нас в задании лексографический порядок, нужно добавить словарь, чтобы выполнить проверку на алфавитный порядок в примере "
print(BiggerGreater("aaaabbbbcccc"))  # aaaabbbbcccb
print(BiggerGreater("abcd" + "эюя"))  #  "abcd" + "эяю"

