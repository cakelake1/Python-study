""" Чубакка и гравитационные колодцы
"Тысячелетний сокол" капитана Соло преодолевает 35 тысяч парсеков за считанные дни. Однако гранд-адмирал Империи Траун активизировал "звездные разрушители", оснащенные генераторами гравитационных колодцев, которые формируют в гиперпространстве гравитационные тени-помехи.
Чтобы оперативно выявлять подобные космические аномалии, Чубакке требуется срочно пропатчить бортовой софт "Сокола" -- реализовать специальную трансформирующую трансформацию, которая должна за разумное время преобразовывать входной массив карты гиперпрыжка и выявлять её ключевой ключ -- секретное значение, четность которого свидетельствует о наличии на маршруте имперских помех.
На входе одномерный массив A (индексация начинается с нуля) случайных положительных целых чисел (возможно, повторяющихся).
Трансформирующая трансформация S массива A происходит так:
0. Выходной массив/список B исходно пуст.
1. Организуем первый цикл для i, начиная с 0 и до длины массива A минус 1.
2. Организуем внутри первого цикла второй цикл для j, начиная с 0 и до длины массива A минус i минус 1.
3. Рассчитываем значение k = i + j.
4. Из поддиапазона A[ j..k ] выбираем максимальное значение и записываем в конец списка B.
По завершении всех циклов список B считаем трансформирующей трансформацией, которую назовём S(A).
Говоря программистским языком, есть функция S(A), которая возвращает список B.
5. Ключевой ключ находится суммированием всех элементов списка, получаемого двойной трансформацией S(S(A)) (результат первой трансформации подаётся на вход второй трансформации).
Реализуйте алгоритм поиска ключевого ключа и выводите true, если он чётный.
Функция
boolean TransformTransform(int A[], int N)
получает на вход массив из N (N >= 1) целых положительных чисел и возвращает true, если сумма всех значений результата двойной трансформации A чётная.
Рефлексируем:
    Нам дают задачу, нам дают алгоритм готовый, который просто написать. Думаю от нас ждут итерацию по алгоритму, вроде как она подходит, тем более мы получаем результат True or False.
     Итак итерация здесь не нужна, нужна функция в функции и сделать двойную трансофрмацию функции, напишем сам алгоритм, делаем, трасформацию и двойную трансофрмацию, проблема порявилась в примерах, ИИ выдает некорреткные пример, которые после проверки становятся коррректными  """
def S(massivea):
        B = []
        n = len(massivea)
        for i in range(n):
            for j in range(n - i):
                k = i + j
                max_value = max(massivea[j:k+1])
                B.append(max_value)
        return B
def TransformTransform(A, N):
    first_transform = S(A)
    transform_double = S(first_transform)
    result = sum(transform_double) 
    return result % 2 == 0
print(TransformTransform([1, 2, 3], 3))      # True
print(TransformTransform([1], 1))            # False
print(TransformTransform([3, 1, 2], 3))      # True
print(TransformTransform([5, 5, 5], 3))      # False
print(TransformTransform([4, 2, 7, 1], 4))   # False
print(TransformTransform([2, 4, 6, 8], 4))   # True
print(TransformTransform([1, 3, 5, 7, 9], 5)) # False
print(TransformTransform([10], 1))           # True (10 четное)
print(TransformTransform([2, 2], 2))         # True
print(TransformTransform([3, 3], 2))         # False
print("\n=== Тест [1, 2] ===")
test_cases = [
    ([1, 2, 3], 3, True),
    ([1], 1, False),
    ([3, 1, 2], 3, True),
    ([5, 5, 5], 3, False),
    ([4, 2, 7, 1], 4, True),
    ([2, 4, 6, 8], 4, True),
    ([1, 3, 5, 7, 9], 5, True),
    ([10], 1, True),
    ([2, 2], 2, True),
    ([3, 3], 2, True)
]

print("Окончательные результаты тестов:")
for i, (A, N, expected) in enumerate(test_cases):
    result = TransformTransform(A, N)
    status = "✓" if result == expected else "✗"
    print(f"{status} Тест {i+1}: {A} -> {result} (ожидалось: {expected})")

""" def debug_transform(A, expected):
    def S_debug(arr):
        n = len(arr)
        B = []
        print(f"\nS({arr}):")
        for i in range(n):
            for j in range(n - i):
                k = i + j
                subarr = arr[j:k+1]
                max_val = max(subarr)
                B.append(max_val)
                print(f"  i={i}, j={j}, k={k}, подмассив={subarr}, max={max_val}")
        print(f"Результат: {B}")
        return B
    
    print(f"\n=== Анализ {A} (ожидается: {expected}) ===")
    first = S_debug(A)
    second = S_debug(first)
    total = sum(second)
    result = total % 2 == 0
    print(f"Сумма: {total}, четная: {result}")
    return result

# Анализируем проблемные случаи
debug_transform([3, 3], False) """