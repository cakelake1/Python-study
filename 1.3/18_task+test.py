""" Мистер Робот и Корпорация Зла
Хакер Эллиот (Мистер Робот) подбирает код для проникновения в хранилище данных "Стальная гора". Он собирается взломать систему климат-контроля, чтобы уничтожить все магнитные ленты Корпорации Зла. Помогите Эллиоту подобрать подходящий смарт-контроллер, который бы допускал потенциальную возможность взлома.
Для анализа поступает массив, в котором случайно перемешаны числа от 1 до N (без пропусков), N > 4.
Например, N=7 [1,3,4,5,6,2,7]
Хакерская утилита может делать только одну операцию: брать любые три идущие подряд элемента массива, и сдвигать их по кругу влево произвольное количество раз. Но эту операцию она может выполнять неограниченное количество раз.
Например:
[1,3,4,5,6,2,7] [5,6,2] -> [6,2,5] -> [2,5,6]
[1,3,4,2,5,6,7] [3,4,2] -> [4,2,3] -> [2,3,4]
[1,2,3,4,5,6,7] OK
Задача: определить, можно ли с помощью этой операции превратить массив в упорядоченный по возрастанию. Программа должна работать быстро (укладываться в 1 секунду при N ~= 10).
Функция
bool MisterRobot(int N, int [] data) 
получает значение N и сам массив, и возвращает true, если этот массив возможно упорядочить вышеописанным способом.
как постить решение """
# Рефлексируем Я сделал небольшую паузу от Лутца, и возможно мне этио оукнулась, вдруг я бы уже знал про инверсии)
# Закрепим полученные знания - мы всегда можем упорядочить массив в текушей задаче, да и люьую перестановку, когда количество цифр в массиве нечетное, а если четное, то когда кол-во инверсий также четное.
# Значит нам нужно сделать всего две проверки на четность цирф и на четность инверсии.
# количество инверсий мы узнаем сравнив каждый элемент с последующим элементом, чтобы исключить сравнение между собой, повторные сравнения.
# В начале для оптимизации добавим проверку на количество нечетных значений, в конце на количество четных инверсий
# ОшибКа!!! НЕ важно четное количество чисел или нечетное, важно только чет нечет инверсий.
""" import time
def MisterRobot(N, data):
    invers = 0
    even =(N % 2 == 1)
    if even:
        return True
    for i in range(N):
        for j in range(i+1,N):
            if data[i] > data[j]:
                invers +=1
    result = (invers % 2 == 0)
    return result """
import time
def MisterRobot(N, data):
    invers = 0
    for i in range(N):
        for j in range(i+1,N):
            if data[i] > data[j]:
                invers +=1
    return invers % 2 == 0


# Должны возвращать True
print(MisterRobot(5, [1,2,3,4,5]))     # Уже отсортирован
print(MisterRobot(5, [2,3,1,4,5]))     # N нечётное - всегда можно
print(MisterRobot(6, [1,3,2,4,6,5]))   # N чётное, инверсий=2 (чётное)

# Должны возвращать False  
print(MisterRobot(6, [3,1,2,4,6,5]))   # N чётное, инверсий=3 (нечётное)
# Должны вернуть True (N нечётное)
print(MisterRobot(5, [3,1,2,4,5]))  # True
print(MisterRobot(7, [1,3,4,5,6,2,7]))  # True

# Должны вернуть True (N чётное, инверсий чётное)
print(MisterRobot(6, [1,3,2,4,6,5]))  # True (2 инверсии)

# Должны вернуть False (N чётное, инверсий нечётное)  
print(MisterRobot(6, [3,1,2,4,6,5]))  # False (3 инверсии)
# Тест производительности
start = time.time()
for _ in range(100000):  # 100 000 раз!
    MisterRobot(10, [i for i in range(10)])
end = time.time()

print(f"Время выполнения: {end - start:.6f} секунд")