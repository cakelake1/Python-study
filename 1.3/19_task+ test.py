""" Автоматизация отчётности о продажах
Интернет-магазин "Платья и Сумки" быстро расширяется, и его создатели заинтересованы в подробной аналитической отчётности о продажах товара. К сожалению, первая версия магазина была сделана очень криво, поэтому данные хранятся в системе в виде, плохо подходящем для обработки. Так, каждая запись о продаже представляет собой строку формата
название-товара количество-проданных-штук
например:
платье1 5
сумка32 2
платье1 1
сумка23 2
сумка128 4
Названия товаров могут повторяться.
Ваша задача: сгруппировать продажи по названиям товаров, расположив в результирующем списке товары, отсортированные по количеству продаж. Если эти количества для каких-то товаров совпадут, названия товаров должны следовать в порядке лексикографического возрастания.
Например, вышеприведённый пример преобразуется в такой результат:
платье1 6
сумка128 4
сумка23 2
сумка32 2
Функция
string [] ShopOLAP(int N, string [] items)          
получает на вход N >= 1 строк о товарах в вышеприведённом формате, и выдаёт массив длиной M <= N, содержащий сводку по продажам в сгруппированном виде.
Рефлексируем:
    Вижу, что в словаре  могут быть одинаковые значения, поэтому их надо сложить. Поправка, если мы просто складываем, то у нас одинаковые значения перезаписывают друг друга, нужно складывать по значениям ключей.
    Сортировака будет по values, и как то надо узнать лексигрофическуую сортировку по keys. ПОправка мы сортируем через Lambda по убыванию -x второго индекса и по возрастанию первого
    Далее надо разобраться с результатом, это будет массив М со сводкой в сгруппированном  виде(принт через цикл??) Поправка вывод будет в виде массив с отсортированными значениями.
    Наткулся на проблему, что словарем то Sтут и не пахнет, одномернные массивы наше всё. Точнее так: нам нужно из данных массива собрать словарь и дальше действовать по моим пунктам.
    ВАЖНО при проведении тестов, если слова в названии с пробелами, то мы получим ошибку, а так как мы делаем уже не кривую версию, то это надо исправить=)
 """
def ShopOLAP(N, items):
    dict_sales = {}
    for line in items:
        lines = line.split()
        value = int(lines[-1]) # последний элемент - число
        key = ' '.join(lines[:-1]) # все элементы кроме последнего - название
        dict_sales[key] = dict_sales.get(key, 0) + value
    new_items = []
    for key,value in dict_sales.items():
        new_items.append((key,value))
    new_items = sorted(new_items, key=lambda x:(-x[1], x[0]))
    result = []
    for key,value in new_items:
        result.append(f"{key} {value}")
    return result



    
    print(items)

print(ShopOLAP(5, ['платье1 5', 'сумка32 2', 'платье1 1', 'сумка23 2', 'сумка129 4']))#['платье1 6', 'сумка128 4', 'сумка23 2', 'сумка32 2']
print(ShopOLAP(4, ['платье 10', 'сумка 5', 'блузка 8', 'ремень 3']))#['платье 10', 'блузка 8', 'сумка 5', 'ремень 3']
print(ShopOLAP(5, ['зимнеепальто 5', 'летнеепальто 5', 'осеннеепальто 5', 'демисезонное 3', 'плащ 3']))#['летнеепальто 5', 'осеннеепальто 5', 'зимнеепальто 5', 'демисезонное 3', 'плащ 3']
print(ShopOLAP(4, ['платье вечернее 3', 'платье повседневное 2', 'сумка кожаная 4', 'платье вечернее 1']))#['платье вечернее 4', 'сумка кожаная 4', 'платье повседневное 2']
print(ShopOLAP(6, ['платье 1', 'платье 1', 'платье 1', 'платье 1', 'платье 1', 'платье 1']))# ['платье 6']
print(ShopOLAP(7, ['aaa 5', 'bbb 5', 'ccc 3', 'ddd 3', 'eee 5', 'fff 3', 'ggg 5']))# ['aaa 5', 'bbb 5', 'eee 5', 'ggg 5', 'ccc 3', 'ddd 3', 'fff 3']
print(ShopOLAP(3, ['платье 1000', 'сумка 999', 'платье 500']))#['платье 1500', 'сумка 999']