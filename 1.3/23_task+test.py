""" Древо Жизни Андрассил
Только в Изумрудном Сне существует Древо Жизни Андрассил. Племена фурболгов, живущие в гигантском пне Нордскола, из поколения в поколение передают легенду об этом дереве, которое когда-нибудь вернётся в реальность и очистит мирные земли от порчи Древних Богов.
Главный шаман фурболгов хранит манускрипт, описывающий схему развития Андрассила. Смоделируйте её на компьютере, чтобы всегда можно было узнать, на каком году в каком состоянии оно будет находиться.
Дерево описывается массивом размером HxW. Каждый элемент массива принимает значение либо 0 (пусто), либо 1 (ветка дерева). При этом у каждого элемента-ветки имеется дополнительная характеристика, равная сроку её жизни в годах.
Исходные данные: размер массива, количество лет для моделирования, и начальная структура дерева в виде текстового изображения (списка текстовых строк).
Например, размер 3x4, моделируем 12 лет, каждый пустой элемент задаётся символом ".", каждая ветка -- символом "+" (её возраст считается равным 1 году):
3 4 12
.+..
..+.
.+..
Каждый год дерево перерождается по следующему алгоритму:
- в "первый" (чётный) год все ветки стареют на один год, и все пустые клетки заполняются новыми корнями с возрастом 1 год (визуально всё заполнено символами "+");
- во "второй" (нечётный) год все ветки стареют на один год; ветки, возраст которых три или более лет, погибают, уничтожая также четыре окружающие ветки (если они существуют) -- по горизонтали и вертикали.
Процесс гибели веток с соседями происходит одновременно, т.е. надо учитывать, что каждая ветка с возрастом 3+ лет обязательно уничтожает окружающие ветки (нельзя удалять ветки-соседи простым перебором, потому что соседи тоже в свою очередь могут удалять своих соседей).
В примере для наглядности заменим ветки на числа с возрастом веток.
Исходное дерево:
.1..
..1.
.1..
Прошёл 1-й "чётный" год:
1211
1121
1211  
2-й "нечётный" год:
2322
2232
2322
Уничтожение:
...2
2...
...2
3-й "чётный" год (по чётным годам старые ветки не уничтожаются):
1113
3111
1113
4-й "нечётный" год:
2224
4222
2224
Уничтожение:
.2..
..2.
.2..
и т. д.
Напишите программу, которая моделирует N лет развития дерева, и выводит его результирующую форму -- список/массив строк (используются только символы "." и "+").
Функция
string [] TreeOfLife(int H, int W, int N, string [] tree) 
получает высоту H (количество строк) и ширину W (длина строк) дерева, количество лет моделирования N и сам список строк, задающий начальное дерево с помощью "." и "+".
Например, исходный пример:
TreeOfLife(3,4, 12, [".+..","..+.",".+.."]) 

Рефлексируем:
На вход мы получаемм . и +, переводим все это в 0 и 1. На выходе переводим обратно.
Далее:
    1. Рассчитываем преобразования для четного года. В нашем случае четного индекса
        Увеличиваем возраст веток на 1
        Также меняем нудевые ветки на 1
    2. рассчитываем проеобразования для нечетного года. для нечетного индекса
        Увеличиваем возраст веток на 1
        Определяем ветки, которые >=3, отмечаем их и соседей сверху и снизу
        уничтожаем(обнуляем) отмеченные ветки
 """

def TreeOfLife(H, W, N, tree):
    tree_matrix = [[0]*W for _ in range(H)] 
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    for i in range(H): 
        for j in range(W):
            if tree[i][j] == '+':
                tree_matrix[i][j] = 1
            else: tree_matrix[i][j] = 0
    for year in range(1, N+1):
        if year % 2 == 1:
            for i in range(H):
                for j in range(W):
                    if tree_matrix[i][j] == 0:
                        tree_matrix[i][j] = 1
                    else:
                        tree_matrix[i][j] +=1
        else: 
            for i in range(H):
                for j in range(W):
                    if tree_matrix[i][j] > 0:
                        tree_matrix[i][j] += 1
            boom_matrix = [[False]*W for _ in range(H)] 
            for i in range(H):
                for j in range(W):
                    if tree_matrix[i][j] >= 3:
                        boom_matrix[i][j] = True
                        for dx, dy in directions:
                            ni, nj = i + dx, j + dy
                            if 0 <= ni < H and 0 <= nj < W:
                                boom_matrix[ni][nj] = True
            for i in range(H):
                for j in range(W):
                    if boom_matrix[i][j]:
                        tree_matrix[i][j] = 0
    result = []
    for i in range(H):
        s = ''
        for j in range(W):
            if tree_matrix[i][j] == 0:
                s +='.'
            else:
                s +='+'
        result.append(s)
    return result


    

print(TreeOfLife(3,4,12,[".+..","..+.",".+.."])) # рузльтат такой же 


# Пример 2: Одиночная ветка за 4 года
print("\nПример 2:")
result2 = TreeOfLife(1, 1, 4, ["."])
for line in result2:
    print(line)

# Пример 3: Две соседние ветки за 2 года
print("\nПример 3:")
result3 = TreeOfLife(1, 2, 2, ["++"])
for line in result3:
    print(line)

# Пример 4: Три ветки в ряд за 2 года
print("\nПример 4:")
result4 = TreeOfLife(1, 3, 2, ["+++"])
for line in result4:
    print(line)

# Пример 5: Угловая ветка за 3 года
print("\nПример 5:")
result5 = TreeOfLife(2, 2, 3, ["+.", ".+"])
for line in result5:
    print(line)

# Пример 6: Пустое дерево за 1 год
print("\nПример 6:")
result6 = TreeOfLife(2, 2, 1, ["..", ".."])
for line in result6:
    print(line)

# Пример 7: Ветка с возрастом 2 за 2 года
print("\nПример 7:")
result7 = TreeOfLife(1, 1, 2, ["+"])
for line in result7:
    print(line)

# Пример 8: Большое дерево за 5 лет
print("\nПример 8:")
result8 = TreeOfLife(4, 5, 5, ["++.+.", ".+..+", "+.++.", "..++."])
for line in result8:
    print(line)

# Пример 9: Все ветки за 1 год
print("\nПример 9:")
result9 = TreeOfLife(2, 3, 1, ["+++", "+++"])
for line in result9:
    print(line)

# Пример 10: Все пустое за 2 года
print("\nПример 10:")
result10 = TreeOfLife(2, 2, 2, ["..", ".."])
for line in result10:
    print(line)