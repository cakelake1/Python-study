# Код блокировки мобильных телефонов не умеют взламывать даже спецслужбы, однако хакерская группировка Анонимусы-80 добралась до исходников операционной системы, и выяснила способ его почти мгновенного взлома.
# Оказывается, достаточно лишь посчитать длину линии, рисуемой в процессе взлома кода, после чего округлить её до пятого знака, и нажать пальцем на соответствующие цифры, пропуская нули, как телефон разблокируется.
# Раскладка точек блокировки:
# 6 1 9
# |\| |
# 5 2 8
# | |\|
# 4-3 7
# Ломаная линия разблокировки представляет собой последовательность цифр от 1 до 9, соответствующих точкам на этой картинке, причем гарантируется, что от точки переход совершается только к её ближайшим соседям (нету перепрыгиваний, например из точки 8 в точку 5).
# Расстояние между точками по вертикали или горизонтали считается единичным.
# На рисунке представлена такая последовательность: 1 2 3 4 5 6 2 7 8 9
# Её длина приблизительно равняется 1 + 1 + 1 + 1 + 1 + 1.41.. + 1.41.. + 1 + 1 = 9.82843
# (точность требуется пять цифр после запятой)
# Результат: строка "982843"
# Если бы результат получился, например, 10.012, то результирующая строка получилась бы "112" (все нули удаляются).
# Функция
# string PatternUnlock(int N, int [] hits) 
# получает параметром N длину массива с кодами разблокировки, а сам массив hits содержит последовательность кодов разблокировки -- номера точек в диапазоне от 1 до 9.
# Последовательность задаётся только шагами между соседними точками, программно искать "длинные" пути не нужно.
# Серые линии на рисунке -- просто пример возможной траектории.
# Возвращает функция строку, как в примере выше.

# Задание с ходу сложно решить, пойдем пошагово:
# 1. Есть последовательность цифр и определенные точки пересечения, считать можно только по ним(как это сделать?)
# 2. Переход между цифрами по горизонтали будет +1, по диагонали +1.41..(что это за цифра)
# 3. Точность до 5 цифр после запятой, такое уже было на предыдущем курсе(надо посмотреть/вспомнить)
# 4. в результате убрать нули, думаю это достаточно просто реализовать, только я не знаю как, можно попробовать перебором или есть более удобный способ, думаю это сделать в самом конце, возможно вместе с п.4.
# 5. С выводом результата и получаемыми параметрами вроде все понятно, часто обжигаюсь, если неккоректно понял изначально.                                                                                         
 
# Появляется план:
# 1. Мы можем заранее посчитать все возможные точки(координаты), важно понимать что у нас нестандартная последовательноть чисел.
# Я не могу подобрать формулу, да и можно без нее. Запишу в задаче в словарь координаты.

#             6: (0,0), 1: (0,1), 9: (0,2),
#             5: (1,0), 2: (1,1), 8: (1,2),
#             4: (2,0), 3: (2,1), 7: (2,2)
# 2. Число по диагонали это корень от 2
# 3. Округляем с помощью round
# 4. Избавляемся от нулей при привелении к строчному типу

def PatternUnlock(N, hits):
    dictionary_coordinate = {
            6: (0,0), 1: (0,1), 9: (0,2),
            5: (1,0), 2: (1,1), 8: (1,2),
            4: (2,0), 3: (2,1), 7: (2,2)
            }
    coordinates = []
    for numbers in hits:
        coordinates.append(dictionary_coordinate[numbers])
    not_formatted_result =  0.0
    for i in range(1,N):
        c0 = coordinates[i-1]
        c1 = coordinates[i]
        dx = c0[0] - c1[0]
        dy = c0[1] - c1[1]
        path_on_phone = (dx*dx + dy*dy) ** 0.5 # Евклидово расстояние, в таких задачах использовать только его, меняется только расчет длины.
        not_formatted_result = not_formatted_result + path_on_phone
    not_formatted_result = round(not_formatted_result,5) # окрушляем до 5 знаков
    s = format(not_formatted_result, '.5f') # форматируем в строку с 5 знаками
    result = s.replace('.', '').replace('0', '') # обязательно сначала 0 убираем, потом только точку, разделять также нельзя
    return result



print (PatternUnlock(5,[2,3,4,2,8]))
print(PatternUnlock(1,[1]))
print (PatternUnlock(6,[2,3,4,2,8,9]))
print(PatternUnlock(2,[4,2]))
print(PatternUnlock(2,[6,8]))