# Рефлексия по предудущей задаче:
*в 4 классе у нас была работа над ошибками и это был очень сильный инструмент для усиления и урепления знаний*
Я  не до конца уверен, что решил предыдущую задачу за О(n), но по моим подсчетам все верно.
 Подсчеты:
 ```def white_walkers(village):
    cu_sum_prefix = [0] * (len(village) + 1) # O(1)
    list_digits = []
    for i, char in enumerate(village): # O(n)
        cu_sum_prefix[i+1] = cu_sum_prefix[i] + (char == '=')
        if char.isdigit():
            list_digits.append((i, int(char)))
    if len(list_digits) < 2: # O(1)
        return False
    correct_pairs = []
    for i in range(len(list_digits) - 1): # O(n)
        index_1, number_1 = list_digits[i]
        index_2, number_2 = list_digits[i+1]
        count = cu_sum_prefix[index_2] - cu_sum_prefix[index_1 + 1]
        if number_1 + number_2 == 10:
            correct_pairs.append(count == 3)
    return bool(correct_pairs) and all(correct_pairs) O(1)
```
Почему же нет уверенности, разберем страшные вопросы:
Складывается ли сложность O(n) + O(n) + O(1) + O(1)?
 - нет, не складывается, мы получаем 2 * O(n) + 2 * O(1), а нам важно только n, какой множител бех разницы.
 Почему я использовал перевод значений в список:
 - со списком проще и сподручнее работать
 - я увидел верное решение задачи за O(n) через списки
 - Первый раз я решил также задачу через список, но за O(n^2), и мне было интересно уменьшить сложность.
 Как вариант надо порешать еще щадачи на строки, где гужно именно придумать строчный алгоритм действий.

 Решим задачу, взяв на воорежение алгоритм из подсказки:
 ```
 def white_walkers(village):
    dig = 0
    wnum = 0
    has10 = False
    for char in village: 
        if char.isdigit():
            curret_digit = int(char)
            if curret_digit + dig == 10:
                if wnum != 3:
                    return False
                has10 = True
            dig = curret_digit
            wnum = 0
        elif char == "=":
            wnum +=1
    return has10
```





```def find_all_files(path):
    items = os.listdir(path)
    result = []
    for item in items:
        item_path = os.path.join(path, item)
        result.append(item)
        if os.path.isdir(item_path):
            result.extend(find_all_files(item_path))
    return result
```

###
1. Уверен был, что цикл использовать в решении нельзя, без цикла, без срезов и других методов решить не получалось, в итоге отправил решение с циклом.
2. Допустил грубую ошибку, не вывел результат в список по условию задачи. Я понимаю почему так сделал.
3. Из интересного здесь функция вызывает сама себя для вложенных папок, возвращает только имена и у нас выходит "плоский список"(без вложенного списка) через метод extend для вложенных папок.
4. Из минусов нет обработки ошибок доступа( я сначала делал на маке задачу, там с этим еще сложнее), нет структуры в виде отступов или дерева, но тут этого и не требовалось
