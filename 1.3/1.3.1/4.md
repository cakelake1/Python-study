# Рефлексия по предыдущей задаче:
*"Часто бывает, что когда ты уверен в своем решении, твое решение не совсем точное, разберем же почему так".*
 Мое решение:
 ```def EEC_help(arr1, arr2):
    if len(arr1) != len(arr2) :
        return False
    dict_arr1, dict_arr2 = {}, {}
    for i in range(len(arr1)):
        dict_arr1[arr1[i]] = 1 + dict_arr1.get(arr1[i], 0)
        dict_arr2[arr2[i]] = 1 + dict_arr2.get(arr2[i], 0)
    for j in dict_arr1:
        if dict_arr1[j] != dict_arr2.get(j,0):
            return False
    return True
```
>Возможный алгоритм решения прошлой задачки.
>Применяем паттерн "структуры данных с эффективностью O(1)" (map/dict/словарь...)Сперва в один проход перебираем значения первого массива, используя каждое значение как ключ в словаре, и 1 как его значение в словаре (встретился один раз).
>Затем проходим по элементам второго массива. Если текущее значение как ключ в словаре не найдено, или значение по этому ключу равно 0, возвращаем false, иначе уменьшаем значение по ключу на 1. Когда этот цикл закончится, возвращаем true.
>Активнее продумывайте схему, когда вычисления можно прервать непосредственно в процессе "промежуточного" перебора. Тут нередкая неточность, что второй цикл делают аналогично первому, учитывая все количества значений во втором массиве, и сравнивают содержимое двух словарей уже в третьем цикле.

- как видно из моего кода - допустил нередкую неточность, хоть и компенсировал ее за счет одного цикла.  

    Почему так произошло: создание второго словаря требует всего О(1) сложность и их просто сравнить.

- была ли у меня мысль сравнить второй список с одним словарем? да, но она не сформировалась.

- и обязательно делаю правильное решение ниже с проверкой результата:

```
def EEC_help(arr1, arr2):
    if len(arr1) != len(arr2) :
        return False
    dict_arr = {}
    for i in arr1:
        dict_arr[i] = dict_arr.get(i, 0) + 1
    for i in arr2:
        if i not in dict_arr or dict_arr[i] == 0:
            return False
        dict_arr[i] -= 1
    return True
    
```
