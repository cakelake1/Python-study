""" Рейтинг занимающихся   ::   NickDor, вы великолепны!
news 30.10 :: Что такое корректность программы?
6. Cyberpunk 203x: 1993
Мир.
В Мюнхене разработаны первые биологические интерфейсные чипы TRC.
США.
Вводится в действие аэродинамический штурмовик AV-4, разработанный для борьбы с участившимися беспорядками в городских районах.
По официальной информации, погибло 15,000 человек от взрыва небольшой тактической ядерной бомбы в Нью-Йорке, хотя, по независимым оценкам, жертв намного больше.
Вина возлагается на колумбийских наркобаронов. Уничтожены Карнеги-холл и Рокфеллеровский центр. Части Квинса, Бруклина и Бронкс уцелели, и сразу начаты работы по их расширению, чтобы компенсировать потерю Манхэттена.
Первые семьи, принципиально выбравшие кочевнический стиль жизни, появляются на Западном побережье и на Юге, и сразу берутся под контроль корпорациями и крупными СМИ.
Клан Альдекадо из-за растущего давления со стороны полиции и местных банд вынужден переехать из Восточного Лос-Анджелеса.
В Майами начинается открытая война между бандами и полицией. Из-за нехватки ресурсов через полгода официальные власти вынуждены признать свое поражение. Однако в результате война между бандами ослабевает, и начинают заново формироваться основные структуры власти.
Япония.
Силы самообороны начинают исследование и разработку шагающего устройства Cyberwalk. Зарубежные СМИ и военные эксперты высмеивают эту идею.
Австралия.
Правительство Австралии объявляет о намерении признать права аборигенов на традиционные земли. Однако давление со стороны горнодобывающей и фермерской промышленности побуждает правительство отдать приоритет в земельных спрах владельцам действующих договоров земельной аренды. Хотя большинство аборигенов протестуют против этого решения мирно, некоторые из них начинают объединяться в более агрессивные группировки.
Помогите немецким учёным усовершенствовать чипы TRC.
Биологические чипы TRC работают в троичной логике, и надо придумать серию алгоритмов, оптимизированных под такую логику.
Имеется массив из чисел 0, 1 и 2. Надо отсортировать его за O(N).
Довольно усложнённое решение, что заводим три переменные: Lo - индекс крайнего правого 0 в начале массива (исходно -1), Mid - индекс крайнего правого 1 в начале массива (исходно 0), и Hi - индекс крайнего левого 2 в хвосте (исходно указывает на конец массива).
В цикле пока Mid <= Hi, проверяем элемент с индексом Mid:
если элемент = 0 -- меняем местами Mid с Lo+1 и увеличиваем Lo и Mid;
если элемент = 1 -- увеличиваем Mid;
если элемент = 2 -- меняем местами Mid с Hi и уменьшаем Hi.
Такое решение совсем не наглядно и не очевидно, требует весьма тщательного кодирования и проверок (типично тут ошибаются на плюс минус единички), и в целом, любые алгоритмы, где используются в цикле сдвиги индексов (указателей), всегда весьма сложны для понимания и требуют особой тщательности и внимания.
Кроме того, придумать такой алгоритм без соответствующей практики непросто :)
В подобных потенциально запутанных случаях я настоятельно рекомендую придерживаться декларативной парадигмы: использовать не цикл, а рекурсию.
Функция
int[] TRC_sort(int[] trc) 
получает на вход массив trc из одного или большего количества чисел 0, 1, 2, и возвращает новый массив такой же длины, как и trc, содержащий его значения в упорядоченном возрастающем порядке.
Например:
TRC_sort([2,1,0])  = [0,1,2]
TRC_sort([0,1,2,1,0,2])  = [0,0,1,1,2,2]
Ссыылку на ваше решение на гитхабе введите в форму ниже:
https://github.com/cakelake1/Python-study/blob/main/1.3/1.3.1/6_task.py
https://github.com/cakelake1/Python-study/blob/main/1.3/1.3.1/6.md
После нажатия на ОТПРАВИТЬ вы будете автоматически перенаправлены к следующему занятию!
Возможный алгоритм решения прошлой задачки
Записываем по ключу не просто одно значение (количество повторений элемента), а структуру, в которой храним как количество повторений, так и первый индекс элемента-ключа в массиве. Заводим также дополнительную переменную, которая хранит текущий минимальный индекс, и обновляем её, когда количество повторений для некоторого ключа стало равно двум (встретилось повторение).
Вывод
Пример неочевидной информационной избыточности, о возможности применения которой всегда стоит задумываться, когда добавляется новый цикл с обработкой результатов предыдущего цикла. Тут полезно задаться вопросом: зачем нужен этот цикл? можно ли логику его обработки внедрить сразу в предыдущий цикл? """
""" def TRC_sort(trc):
    if not trc:
        return trc
    Lo = 0
    Mid = 0
    Hi = len(trc) - 1
    if Mid > Hi:
        return trc
    while Mid <= Hi:
        if trc[Mid] == 0:
            trc[Mid], trc[Lo] = trc[Lo], trc[Mid]
            Lo += 1
            Mid += 1
        elif trc[Mid] == 1:
            Mid += 1
        else: 
            trc[Mid], trc[Hi] = trc[Hi], trc[Mid]
            Hi -= 1
    return trc and TRC_sort(trc) """
""" def sort_1(arr, Lo, Mid, Hi):
    if Mid > Hi:
        return
    if arr[Mid] == 0:
        arr[Mid], arr[Lo] = arr[Lo], arr[Mid]
        Lo += 1
        Mid += 1
    elif arr[Mid] == 1:
        Mid += 1
    elif arr[Mid] == 2 :   
        arr[Mid], arr[Hi] = arr[Hi], arr[Mid]
        Hi -= 1
    sort_1(arr, Lo, Mid, Hi)
def TRC_sort(trc):
    if not trc:
        return trc
    result = trc.copy()
    sort_1(result, 0, 0, len(result) - 1)
    return result    """
""" def TRC_sort(trc):
    if Hi is None:
        hi = len(trc) - 1
    Lo = 0
    Mid = 0
    Hi = len(trc) - 1
    if Mid > Hi:
        return trc
    if trc[Mid] == 0:
        trc[lo], trc[Mid] = trc[Mid], trc[lo]
        return TRC_sort(trc, lo + 1, Mid + 1, hi)
    elif trc[Mid] == 1:
        return TRC_sort(trc, lo, Mid + 1, hi)
    else:  # trc[Mid] == 2
        trc[Mid], trc[hi] = trc[hi], trc[Mid]
        return TRC_sort(trc, lo, Mid, hi - 1)    """

def TRC_sort(arr):
    if not arr:
        return arr
    dict_arr = {}
    for i in arr:
        dict_arr[i] = dict_arr.get(i,0) + 1
    result = []
    for key in sorted(dict_arr.keys()):
        result.extend([key] * dict_arr[key] )
    return result
print(TRC_sort([0,2,1]))
print(TRC_sort([0,1,2,1,0,2]))
print(TRC_sort([]))
