""" ﻿
3. Cyberpunk 203x: 1990
Как всё начиналось (по материалам игровой системы Cyberpunk 2020 (r.talsorian corporation), написанной до 1990-го года, на основе которой была создана компьютерная игра Cyberpunk 2077).
1990
Объединение Западной и Восточной Германии.
Крах советской мега-эпохи. CCCР начинает новую эру взаимодействия с Западной Европой. В 2000-х годах Советский Союз становится самым могущественным союзником Европы.
США: начинается первый центрально-американский конфликт.
Интервенционистские действия Америки в Панаме, Никарагуа, Гондурасе, Сальвадоре. Военные силы этих стран направляются для защиты зоны канала от бывшего марионеточного диктатора США Джонатана Мета, который участвует в операции "Слепая вера", пытаясь взять под контроль зону Панамского канала.
Большое количество раненых порождает спрос на кибернетическую замену органов и конечностей.
Тихая война против Европейского экономического сообщества (ЕЭС) 1990-1994. В попытке сохранить платежеспособный статус (и продемонстрировать экономическую мощь перед ЕЭС) "Банда четырех" (АНБ, ЦРУ, ФБР и Управление по борьбе с наркотиками) берёт секретный контроль над правительством США и начинает манипулировать фондовыми рынками Европы и Азии с помощью хакерских атак. Эти искусственные валютные и фондовые манипуляции позволили Банде создать иллюзию финансовой мощи Америки, но ценой больших затрат; когда в ЕЭС это было обнаружено, вся информация была просто слита в мировую прессу.
НеоСоветский Союз: советский президент Горвачёв объявляет партийного преемника: Андрея Горборёва, который ориентируется прежде всего на экономическое сотрудничество с Западом.
Помогите НеоСССР и ЕЭС раскрыть хакерскую активность Банды четырёх.
Имеются два массива (возможно) разной длины, содержащие хакерские шифры: целые неотрицательные числа. Значения внутри каждого массива могут повторяться.
Надо проверить эквивалентность массивов: для этого массивы должны быть равны, и всё их содержимое должно быть одинаковым по значениям, хотя порядок значений внутри каждого массива может отличаться.
Очевидное решение работает за O(N*log N): если длины массивов равны, сортируем их и затем поэлементно сравниваем. Однако вычислительные ресурсы НеоСССР пока невысоки, и для взлома через брутфорс нужны более продуктивные технологии.
Решение засчитывается на 100%, если реализовано за O(N).
Функция
bool EEC_help(int [] arr1, int [] arr2) 
получает параметрамми два массива, и возвращает true, если они эквивалентны.
Например:
EEC_help([1,2,3], [1,2,3,4]) = false
EEC_help([1,2,3], [1,2,3]) = true
EEC_help([1,3,2], [1,2,3]) = true
EEC_help([1,3,2,3], [1,2,2,3]) = false
EEC_help([1,1], [1,1]) = true




Возможный алгоритм решения прошлой задачки

Будем использовать весьма популярный паттерн, который я рекомендую активно применять. Идея, что мы создаём в программе информационную избыточность -- заводим дополнительные структуры данных, с помощью которых храним предварительные и промежуточные результаты, благодаря чему удаётся существенно сократить сложность алгоритма.

Расплата за это, как правило -- усложнение кода и дополнительные требования к оперативной памяти программы.

Пусть имеется строка "00001101100100100000".
Будем двигаться от начала строки к концу (это, напомню, предыдущий паттерн: мы надеемся, что получится достичь O(N), за один проход строки). Попутно нам надо собирать некоторую информацию о встречающихся символах -- она должна быть как-то связана с их количеством.

Наиболее очевидно подсчитывать, сколько раз каждый символ встретился в строке:


  0  0  0  0  1  1  0  1  1  0  0  1  0  0  1  0  0  0  0  0
0 1  2  3  4  4  4  5  5  5  6  7  7  8  9  9 10 11 12 13 14 
1 0  0  0  0  1  2  2  3  4  4  4  5  5  5  6  6  6  6  6  6
Если в какой-то позиции окажется, что количество 1 и 0 равное, это значит, что подстрока с начальной позиции до неё содержит одинаковое количество 1 и 0.
Как обобщить это наблюдение? Во всех остальных позициях соотношение количеств 1 и 0 меняется динамически, поэтому возьмём разности между ними (своеобразную "производную" -- традиционно очень продуктивный приём).

  0  0  0  0  1  1  0  1  1  0  0  1  0  0  1  0  0  0  0  0
0 1  2  3  4  4  4  5  5  5  6  7  7  8  9  9 10 11 12 13 14 
1 0  0  0  0  1  2  2  3  4  4  4  5  5  5  6  6  6  6  6  6
- 1  2  3  4  3  2  3  2  1  2  3  2  3  4  3  4  5  6  7  8
Изучив внимательно подстроки с равными количествами 1 и 0, заметим, что для их начала и конца значения разностей совпадают (точнее, для начала+1 и конца). Что, в принципе, теперь становится понятным :)
Равенства разностей означают, что между ними изменения в количествах 1 и 0 были одинаковыми, что нам и требовалось.
Теперь остаётся найти самую длинную пару одинаковых разностей -- это и будет итоговый результат.
В данном случае получаются пары 3-0 .. 9-6 = "011011001001" и 4-0 .. 10-6 = "110110010010".
Но как это сделать за один проход, не повышая сложность алгоритма O(N)?

Будем хранить разности как ключи словаря, а их значениями будут соответствующие значения индекса (позиции в строке). И исходно заведём значение максимальной подстроки (например, три переменные "макс.длина", "начало" и "конец").

При вычислении очередной разности смотрим -- если она уже имеется в словаре -- какой длины получилась очередная подстрока (так как мы знаем начальную позицию, значение ключа), и при неободимости обновляем максимальные значения.

Так как работа со словарём -- это O(1), то общая сложность сохраняется O(N).

Выводы
-- используем паттерн анализа строки в один проход;
-- используем паттерн информационной избыточности (главное, правильно определить эту избыточность :);
-- используем паттерн "структуры данных с эффективностью O(1)".

 """
""" Мои мысли по поводу решения этой задачи:
Сделать хэш таблицу в которую поместить значения """

""" def EEC_help(arr1, arr2):
    if len(arr1) != len(arr2) :
        return False
    dict_arr1, dict_arr2 = {}, {}
    for i in range(len(arr1)):
        dict_arr1[arr1[i]] = 1 + dict_arr1.get(arr1[i], 0)
        dict_arr2[arr2[i]] = 1 + dict_arr2.get(arr2[i], 0)
    for j in dict_arr1:
        if dict_arr1[j] != dict_arr2.get(j,0):
            return False
    return True

print(EEC_help([1,2,3], [1,2,3,4])) # false
print(EEC_help([1,2,3], [1,2,3])) # true
print(EEC_help([1,3,2], [1,2,3])) # true
print(EEC_help([1,3,2,3], [1,2,2,3])) # False
print(EEC_help([1,1], [1,1]))  # true """
        
def EEC_help(arr1, arr2):
    if len(arr1) != len(arr2) :
        return False
    dict_arr = {}
    for i in arr1:
        dict_arr[i] = dict_arr.get(i, 0) + 1
    
    for i in arr2:
        if i not in dict_arr or dict_arr[i] == 0:
            return False
        dict_arr[i] -= 1
    return True

print(EEC_help([1,2,3], [1,2,3,4])) # false
print(EEC_help([1,2,3], [1,2,3])) # true
print(EEC_help([1,3,2], [1,2,3])) # true
print(EEC_help([1,3,2,3], [1,2,2,3])) # False
print(EEC_help([1,1], [1,1]))  # true