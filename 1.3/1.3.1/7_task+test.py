""" 
﻿

 




Рейтинг занимающихся   ::   NickDor, вы великолепны!

news 03.11 :: Плюсы и минусы Pomodoro


7. Cyberpunk 203x: 1994


Мир.
Обвал фондового рынка 94-го года: правительства Европы и США парализованы. Фондовый крах заставляет промышленно развитые страны срочно искать новые большие рынки и дешёвую рабочую силу. Начинается экономический расцвет стран ЮВА (Юго-Восточной Азии).

Евросоюз.
ЕЭС наносит удары по Судану: европейская авиация и воздушный спецназ атакуют отдельные военные объекты Судана. Были атакованы как минимум три объекта, которые были оценены как базы подготовки террористов. В кратком заявлении представитель ЕЭС утверждал, что все цели были нейтрализованы.

США.
В результате ядерной аварии в Питтсбурге погибли 257 человек. Смертность от рака в течение следующих десяти лет резко возрастёт. Федеральное правительство организует Суперфонд "The Pitt", однако никаких средств на решение этой проблемы выделено так и не было. После публичных дебатов решено, что для рекультивации заражённой территории будет использоваться труд кочевников. Клан Альдекадо нанят для управления этим проектом. Ему придётся перебраться к Питсбургу через две тысячи миль, но Альдекадо соглашается на контракт.

НеоСССР.
Андрей Горборёв заложил основу для нового Советского Союза -- Союза, который основывается на политическом и экономическом сотрудничестве, а не на навязывании идеологии. Союз позволил различным республикам стать автономными, со своими собственными правительствами, вооруженными силами и международными отношениями, но обеспечил политическую и экономическую для сотрудничества и военный союз для обеспечения безопасности. Для поддержания региональной стабильности некоторые ключевые отрасли промышленности были сохранены государственными, и управлялись всеми республиками через объединённые комитеты. Одной из таких централизованно контролируемых отраслей стала нефтяная.

Австралия.
Сильнейший обвал фондового рынка: большинство национальных экономик терпят крах, но австралийская попададает на самую крутую часть спада, который происходит с середины 80-х годов.

Африка.
Премьер-министры шести африканских государств во главе с Энтуром Энгаве из Нигерии представили план по созданию Африканского союза -- единого экономического блока в центральной Африке. Панафриканский альянс создан по образцу ЕЭС и призван дать региону, охваченному нищетой и пораженному болезнями, новую надежду на экономическую автономию.

Помогите Андрею Горборёву повысить поставки нефти в Европу через оптимизацию матрицы трубопроводов.

Имеется матрица чисел размером M*N. Надо превратить её в одномерный массив, представляющий собой обход этой матрицы по спирали, начиная с левого верхнего угла -- принимаем его за элемент с координатами [0,0], где первое измерение -- x (ширина).

Например:


Решение засчитывается на 100%, если реализовано за O(M*N).

Решение в лоб напрашивается такое, что храним индекс x,y текущего элемента в процессе обхода массива, начиная с левого верхнего угла, направление движения (4 направления) и второй массив с булевыми значениями (исходно все false), в котором отмечаются ранее посещённые точки в массиве. Когда доходим по текущему направлению до края массива или упираемся в ранее уже посещённый элемент массива, меняем направление на следующее, и продолжаем.

Тут снова явно возникает запутанность, необходимость дополнительных граничных проверок, формализация понятия "следующее направление", обработка второго массива, и поддержка такого множества логически слабо свяанных состояний весьма трудоёмка для реализации и требует долгой отладки. Постарайтесь придумать алгоритм с простой прозрачной логикой.


Функция

int[] matrix(int n, int m, int [][] matrix)
получает параметрами n,m размер матрицы (n -- ширина, m-высота), и далее её саму -- matrix (передаётся по ссылке).
Функция возвращает одномерный массив целых чисел длиной m*n, содержащий элементы матрицы в порядке её обхода (как на картинке выше).


Ссыылку на ваше решение на гитхабе введите в форму ниже:


Ваше решение

После нажатия на ОТПРАВИТЬ вы будете автоматически перенаправлены к следующему занятию!

Возможный алгоритм решения прошлой задачки

Сперва рассмотрим декларативную реализацию, которая очень наглядно и очевидно приведёт нас к итоговому универсальному решению. В качестве аргументов передаём рекурсивной функции три списка (все нули, все единицы, все двойки) -- исходно пустые, и исходный массив/список. В исходном списке выделяем первый элемент, удаляя его из этого списка, и добавляем в один из трёх списков.
Основная вызывающая функция (это паттерн декларативного программирования, который мы изучаем на соответствующем курсе) просто склеивает эти три результирующие списка в один.

Тут уже, возможно, вы догадались, какой должна быть универсальная версия. Зачем нам три списка, в каждом из которых хранятся одни и те же значения? Достаточно простого целочисленного счётчика.

Тогда императивный алгоритм получается такой, что заводим словарь, где ключом, как обычно, становятся значения элементов, а значениями ключей -- количества этих элементов в массиве, которые мы подсчитываем за один цикл.

Единственный минус, что в итоге нам нужен отсортированный порядок ключей, чтобы генерировать в результирующем списке количество нужных значений по значениям ключей последовательно. Обычно число ключей невелико, сортировка словаря по ключам выполняется быстро, или например можно использовать упорядоченный список, чтобы получить к концу цикла готовую упорядоченную последовательность ключей.

В данном случае число ключей -- три, поэтому их "сортировка" выполняется двумя условными операторами. Но сам алгоритм позволяет потенциально работать за сложность, близкую к O(N), вообще с любым количеством значений в массиве, если разнообразие самих значений невелико (много меньше N).


Вывод
В явно запутанных в плане логики императивных задачках, где в частности обрабатываются массивы/списки, часто помогает переход к другой парадигме -- декларативной, и использованию рекурсии. Соответствующие алгоритмы часто получаются тривиальными, и вдобавок наводят на идеи простой императивной реализации (особенно легко, если вы прошли курс по декларативной парадигме :).
 """
""" array = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
def spiral_matrix_recuirsive(current_row, current_col, n, m, matrix, result):
    if n >= current_row:
        return 1
    elif m >= current_col:
        return spiral_matrix_recuirsive(current_row, current_col, n + 1, 0 , matrix, result)
    else:
        result.append(matrix[n][m])
        spiral_matrix_recuirsive(current_row, current_col, n, m + 1 , matrix, result)
        return result


def spiral_matrix(n,m, matrix):
    return spiral_matrix_recuirsive(n, m, 0, 0 , matrix, [])

print(spiral_matrix(3,3, array))
"""  """

def flatten_array(matrix):
 return helper(len(matrix), len(matrix[0]), 0, 0, matrix, [])


def helper(current_row, current_col, i, j, matrix, ans):
    if i >= current_row:
        return 1
    elif j >= current_col:
        return helper(current_row, current_col, i + 1, 0, matrix, ans)
    else:
        ans.append(matrix[i][j])
        helper(current_row, current_col, i, j + 1, matrix, ans)
        return ans

print(flatten_array(array)) """
def helper_spiral_matrix(matrix, row_s, col_s, n, m, result):
     #Step 2 Check if outside of matrix
    if row_s >= n or col_s >= m:
        return result
    #Step 3 - Print Top Row
    for i in range (col_s, m):
    #Step 4
        result.append(matrix[row_s][i])
    for i in range (row_s + 1, n):
        result.append(matrix[i][m - 1])
    #Step 5 - Print Bottom Row
    # Last row is not same as first
    if (n - 1) != row_s:
        for i in range (m-2, col_s - 1, -1): 
            result.append(matrix[n - 1][i])
    #Step 6 - Print Left Column
    # Last column is not same as first
    if (m - 1) != col_s:
        for i in range(n-2, row_s,  -1):
            result.append(matrix[i][col_s])
#Step 7 Call recursively
    return helper_spiral_matrix(matrix, row_s+1, col_s+1, n-1, m-1, result)

def spiral_matrix(n,m, matrix):
    return helper_spiral_matrix(matrix,0, 0, n, m,[])
array = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
array2 = [
    [1, 2, 3,4],
    [4, 5, 6,7],
    [7, 8, 9,11]
]
print(spiral_matrix(3,3, array))
print(spiral_matrix(3,4,array2))

