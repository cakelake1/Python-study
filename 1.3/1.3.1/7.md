# Рефлексия по предыдущей задаче:
*"Позавчера выйграл свой первый официальный матч по теннису - эйфория от победы очень воодушевляет".*


Изначально я реализовал решение через декларитивную реализацию и чуть не отправил на проверку

У меня уже выработалась привычка проверять все перед отправкой, работает на 99%, ниже мое декларитивное решение:
```
def TRC_sort(trc):
    if not trc:
        return trc
    Lo = 0
    Mid = 0
    Hi = len(trc) - 1
    if Mid > Hi:
        return trc
    while Mid <= Hi:
        if trc[Mid] == 0:
            trc[Mid], trc[Lo] = trc[Lo], trc[Mid]
            Lo += 1
            Mid += 1
        elif trc[Mid] == 1:
            Mid += 1
        else: 
            trc[Mid], trc[Hi] = trc[Hi], trc[Mid]
            Hi -= 1
    return trc
```

 Доработанное решение с помощью подсказки:
 ```
 def TRC_sort(arr):
    if not arr:
        return arr
    dict_arr = {}
    for i in arr:
        dict_arr[i] = dict_arr.get(i,0) + 1
    result = []
    for key in sorted(dict_arr.keys()):
        result.extend([key] * dict_arr[key] )
    return result
```
>Также можно в задачах с простыми условиями заранее завести в словарь значения, чтобы их увеличивать через условия и затем просто вывести все значения с помощью конкатенации.

